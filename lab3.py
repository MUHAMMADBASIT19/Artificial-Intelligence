# -*- coding: utf-8 -*-
"""lab3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1imti1i4LxIHtmJswdu-aquzE9zHEFEyt

"Dictionary"
"""

from collections import deque

# Updated graph with renamed cities
pakistan_cities = {
    'Karachi': ['Faisalabad'],
    'Faisalabad': ['Karachi', 'Rawalpindi'],
    'Rawalpindi': ['Faisalabad', 'Sialkot', 'Bahawalpur'],
    'Sialkot': ['Rawalpindi', 'Lahore'],
    'Bahawalpur': ['Rawalpindi'],
    'Lahore': ['Sialkot', 'Islamabad'],
    'Islamabad': ['Lahore', 'Peshawar'],
    'Peshawar': ['Islamabad']
}

# BFS function to find the shortest path
def bfs_shortest_path(graph, start, goal):
    queue = deque([[start]])  # Queue to store paths

    visited = set()  # Set to track visited cities

    while queue:
        path = queue.popleft()  # Pop the first path
        current_city = path[-1]  # Get the last city in the path

        # If the goal is reached, return the path
        if current_city == goal:
            return path

        if current_city not in visited:
            visited.add(current_city)  # Mark the city as visited

            # Explore all the neighboring cities
            for neighbor in graph.get(current_city, []):
                # Create a new path with the neighbor
                new_path = list(path)
                new_path.append(neighbor)

                # Add the new path to the queue for further exploration
                queue.append(new_path)

    return None  # Return None if no path is found

# DFS function to find any path
def dfs_path(graph, start, goal, path=None, visited=None):
    if path is None:
        path = []
    if visited is None:
        visited = set()

    path.append(start)  # Add the current city to the path
    visited.add(start)  # Mark it as visited

    if start == goal:  # If the goal is reached, return the path
        return path

    # Explore each neighbor recursively
    for neighbor in graph.get(start, []):
        if neighbor not in visited:
            result = dfs_path(graph, neighbor, goal, path.copy(), visited.copy())

            # If a valid path is found, return it
            if result:
                return result

    return None  # Return None if no path is found

# -------------------------------------------
# Testing the functions with updated cities
# -------------------------------------------
start_city = "Karachi"
goal_city = "Peshawar"

# Find the shortest path using BFS
bfs_result = bfs_shortest_path(pakistan_cities, start_city, goal_city)
print("BFS Shortest Path from Karachi to Peshawar:", bfs_result)

# Find any path using DFS
dfs_result = dfs_path(pakistan_cities, start_city, goal_city)
print("DFS Path from Karachi to Peshawar:", dfs_result)